%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{Related Work}
\label{cha:related_work}

\section{Serialization Frameworks} % (fold)
\label{sec:serialization_frameworks}

Serialization is the process of encoding system state into a standardized format so that it can be delivered across a network or stored with durability.
For serialization, each language usually provides a corresponding library, such as Java serialization.
In the setting of service oriented architectures, serialization libraries supplied by programming languages are typically not used to encode messages between services,
because each service may be written in a different language. As a result, data consumers will be unable to comprehend data producers.
Cross-language serialization libraries, such as JSON, can solve this problem.
However, formats such as JSON lack a strictly defined structure,
making data consumption more difficult due to poor type-safety guarantees, and the ability for fields to be unilaterally added or withdrawn at any moment without the consumers' knowledge.
What's missing is a "schema" for data exchange between producers and consumers, akin to an API contract.

There have been a few cross-language serialization frameworks that require the data structure to be properly described via schemas.
XML, Avro, Thrift, and Protocol Buffers are among these libraries.
The benefit of having a schema is that it explicitly defines the data's structure, type, and meaning.

Such frameworks allow for schema evolution, but only to a limited extent:
\begin{itemize}
    \item Only the addition, removal and renaming of fields is allowed.
    \item To ensure backwards compatibility, added fields must be optional.
    \item The only fields that can be removed to maintain forward compatibility are optional fields.
    \item To provide both forward and backward compatibility, removed and added fields must be optional.
\end{itemize}
Backward compatibility refers to a consumer using schema X to process data produced by schema X-1,
whereas forward compatibility refers to data produced by schema X being read by consumers using schema X-1.

The need for optional fields in the above cases is due to a lack of information on the consumer, typically this information is supplied with the use of default values.
In order to support required fields with backwards-forwards compatibility, the system should enforce required fields when the consumer and producer agree on the schema,
and only use default values when the consumer and producer disagree on the schema.
These limitations are problematic because, in order to enforce required fields in former case,
validation logic would need to be written repeatedly by programmers (in the same layer as the business logic).
This validation should be in a layer above because, the scale of the validation logic is proportional to the complexity of messages being validated;
for messages with more properties, particularly those with nested objects, the validation footprint can rise dramatically in terms of both line-count and logical complexity.

These frameworks only tackle part of the problem of API evolution in microservices,
because they can only accommodate changes in the schema of records.
They can not manage changes in the API's signature, such as the method of a REST endpoint.
To eliminate potential mismatches and reduce the complexity of the evolution process, we believe it is critical to manage both sorts of evolution's in a single integrated approach.

\section{Service Integration Adapters} % (fold)
\label{sec:service_integration_adapters}

In the context of service-oriented architectures (SOA) there has been extensive
research on the adaptability of services [3, 4, 6, 7, 14, 27]. There are similarities
between SOA and microservices, as both follow a separation of concerns approach
based on services. These two architectures diverge on some relevant features, in
particular on the fact the SOA services are tightly-coupled while microservices are
loosely-coupled. As a consequence, adaptability in SOA is not focused on evolution
but on the integration of microservices. These works [3, 4, 7, 14, 27] on SOA address
and develop adapters for behavioural mismatches among business processes. The
concern is mainly on adapting workflows and most assume that data adaptation is
already defined by developers. Standard service binding technologies (cf. SOAP) use
description languages like WSDL [1] to specify contracts, allowing them to check for
compatibility of services on every remote call, and issue runtime exceptions when some
mismatch happens. Schema registries and service brokers are also used to centralize
10:27
Robust Contract Evolution in a TypeSafe MicroService Architectures
and authorise changes in the service architecture. Schemas can then be checked based
on version identifiers and compatibility relations just like in our case [22].

\section{Chain Adapter} % (fold)
\label{sec:chain_adapter}

\section{Deployment Strategies} % (fold)
\label{sec:deployment_strategies}

\section{Schema Registry} % (fold)
\label{sec:schema_registry}