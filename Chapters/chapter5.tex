%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{Background}
\label{cha:background}

\section{API} % (fold)
\label{sec:api}

An application programming interface (API) allows software modules (eg. products, services, libraries)
to easily communicate with one another by abstracting their underlying implementations and only exposing the relevant objects and operations.

The operations that make up a API are sometimes known as subroutines, methods, requests, or endpoints.
An API specification defines these operations, meaning that it explains how to use or implement them.
APIs are sometimes thought of as contracts, with documentation that represents an agreement between parties:
If party 1 sends a remote request structured a particular way, this is how party 2â€™s software will respond.

APIs provide flexibility and make the design and administration of sofware  easier.

\section{Agile Development} % (fold)
\label{sec:agile_development}

Plan-driven engineering requires us to create a predictive plan before beginning development.
The plan outlines the project's people, resources, and timelines.
Software design is likewise done ahead of time, with implementation anticipated to follow design.

Agile plans serve as a foundation for managing change.
Agile teams plan just as meticulously as conventional teams, but their plans are regularly revised to reflect what they learn during development.

\section{Microservices} % (fold)
\label{sec:microservices}

\subsection{Orchestration Tools} % (fold)
\label{sec:orchestration_tools}

\subsection{Communication Methods} % (fold)
\label{sec:communication_methods}

Martin Fowler, a well-known author in the context of microservices, advocates what he calls "smart endpoints and dumb pipes" for microservices communication.
In the past, Enterprise Service Buses (ESB) ruled the SOA universe,
and it was common to incorporate orchestration and transformation logic into the communication infrastructure,
making the pipe "smart." There were multiple problems with this approach:
the tooling was complex and expensive, and it was difficult to troubleshoot when problems occurred in production environments.

The reverse approach has been adopted with microservices,
where services own their domain-centric logic ("smart endpoints") and use "dumb pipes" as a transport method.
The majority of communication between microservices is done via request/response-based communication or event-driven messaging.
Because these two methods have such dissimilar properties, it's important to weigh their strengths, and the scenarios that call for each.

Request/response-based communication protocols are typically suited for synchronous settings, where the client contacts one receiver at time and can be blocked while waiting for a response.

Event-driven messaging communication protocols are suited for asynchronous settings (the client code or message sender usually doesn't wait for a response) and evolve
contacting multiple receivers or service at time.

HTTP request-response

\section{Type System} % (fold)
\label{sec:type_system}
