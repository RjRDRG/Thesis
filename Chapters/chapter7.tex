%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{Conclusions and Future Work}
\label{cha:conclusions and future work}

Throughout the sections ~\ref{sec:compatibility_verification_design} and ~\ref{sec:compatiblity_verification}, we demonstrated the safety guarantees of our solution while refactoring parts of a distributed system:
deployments that would lead to irremediably incompatible states are rejected, such as a
microservice attempting to utilize a renamed endpoint, or a microservice being deployed before its dependencies are alive and reachable.

\paragraph{}

Additionally, we argued how the proposed solution could be supported under widely adopted workflows and documentation formats, such as DevOp pipelines and the OpenAPI description language.

\paragraph{}

We also discussed approaches to lessen the solution's additional documentation requirements.
Section ~\ref{sec:evolution_representation} provides an IDE tool that automatically identifies unmodified service procedures and possible contract evolutions,
with the goal of minimizing the effort necessary to explicitly document all contract evolutions.

\paragraph{}

The proposed solution is agnostic to the underling application, all of its components don't require the modification of application microservices or their architecture.
We offer a solution that may be plugged into any distributed application that employs HTTP as its communication protocol, with the only condition being that the application endpoints be versioned through path segments or header parameters.

\paragraph{}

One conclusion we can draw from the results is that the latency introduced by an embed adapter is similar to the latency introduced by an additional call between two distinct nodes;
thus, installing the adapter in the same node as the adapted service is unnecessary;
instead, it would be more beneficial to host the adapter in a different node of the same node pool, and use an adapter with a more generic implementation that can handle the adaptation of multiple services.
Such an approach would require fewer computational resources since a distinct adapter replica wouldn't need to be installed on every service replica, in other words a single adapter would serve multiple services.

Furthermore, the acquired findings show that the adapter CPU and memory cost grow with the arrival rate of requests that must be adapted.
If only a small fraction of requests require adaptation, the computational cost of the adapter will be low in comparison to the cost of the application.

\paragraph{}

An interesting avenue to explore would be the implementation of the adapter using HTTP server's that support different threading models, the current implementation
was made under the Blocking I/O (BIO) model.
In the BIO model each request is processed by a different thread, which has a significant thread overhead and cannot handle highly concurrent applications.
The adoption of a Non-blocking I/O (NIO) model,would result in improved performance and lower CPU resource usage than the traditional BIO model.

\paragraph{}

Lastly, we believe it would be interesting to use a formal language to define function resolution in contract evolution specifications.
The current implementation supports function resolutions with one-line java expressions,
the adoption of a formal language would make the compatibility verification process more robust and enable the adapter to be implemented in programming languages other than java.


